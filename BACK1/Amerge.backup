/*******************************************************************************************
 *
 *  Adaptamer merge phase of a WGA.  Given indices of two genomes (at a specified frequency
 *   cutoff), the adaptemer matches between the k-mers are found in a novel, cache-coherent
 *   merge of the sorted k-mer tables for each genome and seed position pairs are output for
 *   each adaptemer match.
 *
 *  Author:  Gene Myers
 *  Date  :  February 2023
 *
 *******************************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
#include <math.h>
#include <pthread.h>

#include "libfastk.h"
#include "DB.h"
#include "align.h"

#undef    DEBUG_MERGE
#undef    DEBUG_SORT
#undef    DEBUG_SEARCH
#undef    DEBUG_HIT
#define   CALL_ALIGNER

#define   MAX_INT64    0x7fffffffffffffffll

#define    TSPACE       100
static int TBYTES;      //  # of bytes per trace element
static int ABYTE;       //  TBYTES is 1

#define   CHAIN_BREAK  500
#define   CHAIN_MIN    100

static char *Usage = "[-v] [-o<out:name>] -f<int> <source1>[.dam] <source2>[.dam]";

static int   FREQ;     //  Adaptemer frequence cutoff parameter
static int   VERBOSE;  //  Verbose output
static int   KMER;
static int   NTHREADS;
static char *PAIR_NAME;
static char *ALGN_NAME;

static int IBYTE;   // # of bytes for an entry in P1
static int IPOST;   // # of bytes in post of a P1 entry
static int ICONT;   // # of bytes in contig of a P1 entry
static int ISIGN;   // byte index in a P1 entry of the sign flag

static int JBYTE;   // # of bytes for an entry in P2
static int JPOST;   // # of bytes in post of a P2 entry
static int JCONT;   // # of bytes in contig of a P2 entry
static int JSIGN;   // byte index in a P2 entry of the sign flag

static int KBYTE;   // # of bytes for a k-mer table entry (both T1 & T2)
static int CBYTE;   // byte of k-mer table entry containing post count
static int LBYTE;   // byte of k-mer table entry containing lcp

static int DBYTE;   // # of bytes for a pair diagonal

static int    CSHIFT;    //  DB1 contig >> CSHIFT = bucket for pair sort
static int    ESHIFT;    //  DB1 entry >> ESHIFT = bucket for pair sort
static int    NBUCKS;    //  # of buckets
static int   *Select;    //  Select[bucket] = thread file for bucket

static int   *IDBsplit;     //  DB split: contig [DBsplit[p],DBsplit[p+1])

typedef struct
  { char  *name;
    uint8 *bufr;
    uint8 *btop;
    uint8 *bend;
    int64 *buck;
    int    file;
  } IOBuffer;

static IOBuffer *N_Units;  //  NTHREADS^2 IO units for + pair temporary files
static IOBuffer *C_Units;  //  NTHREADS^2 IO units for - pair temporary files

typedef struct
  { int   beg;
    int   end;
    int64 off;
  } Range;

extern int rmsd_sort(uint8 *array, int64 nelem, int rsize, int ksize,
                     int nparts, int64 *part, int nthreads, Range *range);


/***********************************************************************************************
 *
 *   POSITION LIST ABSTRACTION:
 *       Routines to manipuate the position or "post" list associated with a k-mer table.
 *
 **********************************************************************************************/

typedef struct
  { int     pbyte;      //  # of bytes for each post (including sign & contig)
    int     cbyte;      //  # of bytes for each sign & contig
    int64   nels;       //  # of posts in the index
    int64   maxp;
    int     freq;
    int64   cidx;
    uint8  *cache;
    uint8  *cptr;

    int     copn;       //  File currently open
    int     part;       //  Thread # of file currently open
    int     nthr;       //  # of file parts
    int     nsqrt;      //  # of threads/slices (= sqrt(nthr))
    int     nlen;       //  length of path name
    char   *name;       //  Path name for table parts (only # missing)
    uint8  *ctop;       //  Ptr top of current table block in buffer
    int64  *neps;       //  Size of each thread part in elements
  } Post_List;

#define POST_BLOCK 1024

//  Load up the table buffer with the next STREAM_BLOCK suffixes (if possible)

static void More_Post_List(Post_List *P)
{ int    pbyte = P->pbyte;
  uint8 *cache = P->cache;
  int    copn  = P->copn;
  uint8 *ctop;

  if (P->part > P->nthr)
    return;
  while (1)
    { ctop = cache + read(copn,cache,POST_BLOCK*pbyte);
      if (ctop > cache)
        break;
      close(copn);
      P->part += 1;
      if (P->part > P->nthr)
        { P->cptr = NULL;
          return;
        }
      sprintf(P->name+P->nlen,"%d",P->part);
      copn = open(P->name,O_RDONLY);
      lseek(copn,2*sizeof(int)+sizeof(int64),SEEK_SET);
    }
  P->cptr = cache;
  P->ctop = ctop;
  P->copn = copn;
}

static Post_List *Open_Post_List(char *name)
{ Post_List *P;
  int        pbyte, cbyte;
  int64      nels, maxp, n;
  int        copn;

  int    f, p, flen;
  char  *dir, *root, *full;
  int    pb, cb, nfile, nthreads, freq;

  dir  = PathTo(name);
  root = Root(name,".ktab");
  full = Malloc(strlen(dir)+strlen(root)+20,"Post list name allocation");
  if (full == NULL)
    exit (1);
  sprintf(full,"%s/%s.post",dir,root);
  f = open(full,O_RDONLY);
  sprintf(full,"%s/.%s.post.",dir,root);
  flen = strlen(full);
  free(root);
  free(dir);
  if (f < 0)
    { free(full);
      return (NULL);
    }

  read(f,&pbyte,sizeof(int));
  read(f,&cbyte,sizeof(int));
  pbyte += cbyte;
  read(f,&nfile,sizeof(int));
  read(f,&maxp,sizeof(int64));
  read(f,&freq,sizeof(int));
  nthreads = nfile;
  nfile    = nfile*nfile;

  P = Malloc(sizeof(Post_List),"Allocating post record");
  if (P == NULL)
    exit (1);
  P->name   = full;
  P->nlen   = strlen(full);
  P->maxp   = maxp;
  P->cache  = Malloc(POST_BLOCK*pbyte,"Allocating post list buffer\n");
  P->neps   = Malloc(nfile*sizeof(int64),"Allocating parts table of Post_List");
  if (P->cache == NULL || P->neps == NULL)
    exit (1);

  nels = 0;
  for (p = 1; p <= nfile; p++)
    { sprintf(P->name+P->nlen,"%d",p);
      copn = open(P->name,O_RDONLY);
      if (copn < 0)
        { fprintf(stderr,"%s: Table part %s is missing ?\n",Prog_Name,P->name);
          exit (1);
        }
      read(copn,&pb,sizeof(int));
      read(copn,&cb,sizeof(int));
      pb += cb;
      read(copn,&n,sizeof(int64));
      nels += n;
      P->neps[p-1] = nels;
      if (pbyte != pb)
        { fprintf(stderr,"%s: Post list part %s does not have post size matching stub ?\n",
                         Prog_Name,P->name);
          exit (1);
        }
      close(copn);
    }

  P->pbyte = pbyte;
  P->cbyte = cbyte;
  P->nels  = nels;
  P->nthr  = nfile;
  P->nsqrt = nthreads;
  P->freq  = freq;

  sprintf(P->name+P->nlen,"%d",1);
  copn = open(P->name,O_RDONLY);
  lseek(copn,2*sizeof(int)+sizeof(int64),SEEK_SET);

  P->copn  = copn;
  P->part  = 1;

  More_Post_List(P);
  P->cidx = 0;

  return (P);
}

static void Free_Post_List(Post_List *P)
{ free(P->cache);
  free(P->neps);
  if (P->copn >= 0)
    close(P->copn);
  free(P->name);
  free(P);
}

static inline void First_Post_Entry(Post_List *P)
{ if (P->cidx != 0)
    { if (P->part != 1)
        { if (P->part <= P->nthr)
            close(P->copn);
          sprintf(P->name+P->nlen,"%d",1);
          P->copn = open(P->name,O_RDONLY);
          P->part = 1;
        }

      lseek(P->copn,sizeof(int)+sizeof(int64),SEEK_SET);

      More_Post_List(P);
      P->cidx = 0;
    }
}

static inline void Next_Post_Entry(Post_List *P)
{ P->cptr += P->pbyte;
  P->cidx += 1;
  if (P->cptr >= P->ctop)
    { if (P->cidx >= P->nels)
        { P->cptr = NULL;
          P->part = P->nthr+1;
          return;
        }
      More_Post_List(P);
    }
}

static inline void Current_Post(Post_List *P, uint8 *here)
{ memcpy(here,P->cptr,P->pbyte); }

static inline void GoTo_Post_Index(Post_List *P, int64 i)
{ int    p;

  if (P->cidx == i)
    return;
  P->cidx = i;

  p = 0;
  while (i >= P->neps[p])
    p += 1;

  if (p > 0)
    i -= P->neps[p-1];
  p += 1;

  if (P->part != p)
    { if (P->part <= P->nthr)
        close(P->copn);
      sprintf(P->name+P->nlen,"%d",p);
      P->copn = open(P->name,O_RDONLY);
      P->part = p;
    }

  lseek(P->copn,2*sizeof(int) + sizeof(int64) + i*P->pbyte,SEEK_SET);

  More_Post_List(P);
}

static inline void JumpTo_Post_Index(Post_List *P, int64 del)
{ int   p;
  int64 i;

  P->cptr += del*P->pbyte;
  P->cidx += del;
  if (P->cptr < P->ctop)
    return;

  i = P->cidx;
  p = P->part-1;
  while (i >= P->neps[p])
    p += 1;

  if (p > 0)
    i -= P->neps[p-1];
  p += 1;

  if (P->part != p)
    { if (P->part <= P->nthr)
        close(P->copn);
      sprintf(P->name+P->nlen,"%d",p);
      P->copn = open(P->name,O_RDONLY);
      P->part = p;
    }

  lseek(P->copn,2*sizeof(int) + sizeof(int64) + i*P->pbyte,SEEK_SET);

  More_Post_List(P);
}


/***********************************************************************************************
 *
 *   The internal data structure for a table (taken from libfastk.c) needs to be visible so
 *     that the "neps" array can be accessed in order to synchronize thread starts.
 *
 **********************************************************************************************/

typedef struct
  { int    kmer;       //  Kmer length
    int    minval;     //  The minimum count of a k-mer in the stream
    int64  nels;       //  # of elements in entire table
                   //  Current position (visible part)
    int64  cidx;       //  current element index
    uint8 *csuf;       //  current element suffix
    int    cpre;       //  current element prefix
                   //  Other useful parameters
    int    ibyte;      //  # of bytes in prefix
    int    kbyte;      //  Kmer encoding in bytes
    int    tbyte;      //  Kmer+count entry in bytes
    int    hbyte;      //  Kmer suffix in bytes (= kbyte - ibyte)
    int    pbyte;      //  Kmer,count suffix in bytes (= tbyte - ibyte)
                   //  Hidden parts
    int    ixlen;      //  length of prefix index (= 4^(4*ibyte))
    int    shift;      //  shift for inverse mapping
    uint8 *table;      //  The (huge) table in memory
    int64 *index;      //  Prefix compression index
    int   *inver;      //  inverse prefix index
    int    copn;       //  File currently open
    int    part;       //  Thread # of file currently open
    int    nthr;       //  # of thread parts
    int    nlen;       //  length of path name
    char  *name;       //  Path name for table parts (only # missing)
    uint8 *ctop;       //  Ptr top of current table block in buffer
    int64 *neps;       //  Size of each thread part in elements
    int    clone;      //  Is this a clone?
  } _Kmer_Stream;


/***********************************************************************************************
 *
 *   ADAPTAMER MERGE THREAD:  
 *     For each k-mer in T1
 *       Find the longest prefix match to one or more k-mers in T2.
 *       If the totwl # of positions of the k-mers in T2, then output the pairs of positions
 *         from P1 & P2 to a file dependent on the slice of the P1 post and the sign of the match.
 *
 **********************************************************************************************/

static int cbyte[41] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                         0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
                         3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5,
                         6, 6, 6, 6, 7 };

static int mbyte[41] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                         0xc0, 0x30, 0x0c, 0x03, 0xc0, 0x30, 0x0c, 0x03, 0xc0, 0x30, 0x0c, 0x03,
                         0xc0, 0x30, 0x0c, 0x03, 0xc0, 0x30, 0x0c, 0x03, 0xc0, 0x30, 0x0c, 0x03,
                         0xc0, 0x30, 0x0c, 0x03, 0xc0 };

#define POST_BUF_LEN  0x1000
#define POST_BUF_MASK 0x0fff

typedef struct
  { Kmer_Stream *T1;
    Kmer_Stream *T2;
    Post_List   *P1;
    Post_List   *P2;
    int          tid;
    uint8       *cache;
    IOBuffer    *nunit;
    IOBuffer    *cunit;
    int64        nhits;
    int64        g1len;
  } SP;

static void *merge_thread(void *args)
{ SP *parm = (SP *) args;
  int tid          = parm->tid;
  uint8 *cache     = parm->cache;
  IOBuffer  *nunit = parm->nunit;
  IOBuffer  *cunit = parm->cunit;
  Kmer_Stream *T1  = parm->T1;
  Post_List   *P1  = parm->P1;
  Kmer_Stream *T2  = parm->T2;
  Post_List   *P2  = parm->P2;

  int     spart;
  int64   tbeg, tend;

  int     cpre;
  uint8  *ctop, *suf1;

  int     eorun, plen;
  uint8  *rcur, *rend;
  uint8  *vlcp[KMER+1];

  int64   apost;
  uint8  *aptr = (uint8 *) (&apost);

  uint8  *vlow, *vhgh;
  int     pdx, cdx;
  int64   post[POST_BUF_LEN + FREQ];

  int     qcnt, pcnt;
  int64   nhits, g1len;

#ifdef DEBUG_MERGE
  int64   Tdp;
  char   *tbuffer;
#endif

  { int j;

    for (j = 0; j < NTHREADS; j++)
      { nunit[j].bend = nunit[j].bufr + (1000000-(IBYTE+JBYTE+1));
        nunit[j].btop = nunit[j].bufr;
        cunit[j].bend = cunit[j].bufr + (1000000-(IBYTE+JBYTE+1));
        cunit[j].btop = cunit[j].bufr;
      }
  }

  cpre  = -1;
  ctop  = cache;
  vhgh  = cache;
#ifdef DEBUG_MERGE
  tbuffer = Current_Kmer(T1,NULL);
#endif

  nhits = 0;
  g1len = 0;

  spart = P1->nsqrt * tid - 1;
  First_Post_Entry(P1);
  First_Post_Entry(P2);
  First_Kmer_Entry(T1);
  First_Kmer_Entry(T2);

  if (tid != 0)
    { GoTo_Post_Index(P1,P1->neps[spart]);
      GoTo_Post_Index(P2,P2->neps[spart]);
      GoTo_Kmer_Index(T1,((_Kmer_Stream *) T1)->neps[spart]);
      GoTo_Kmer_Index(T2,((_Kmer_Stream *) T2)->neps[spart]);
    }

  qcnt = -1;
  tend = ((_Kmer_Stream *) T1)->neps[spart+P1->nsqrt];
  tbeg = T1->cidx;
  while (T1->cidx < tend)
    { suf1 = T1->csuf;
#ifdef DEBUG_MERGE
      printf("Doing %s (%lld)\n",Current_Kmer(T1,tbuffer),T1->cidx); fflush(stdout);
#endif

      if (T1->cpre != cpre)  //  New prefix panel
        { int64  bidx;
          uint8 *cp;

          if (VERBOSE && tid == 0)
            { pcnt = ((T1->cidx - tbeg) * 100) / (tend-tbeg); 
              if (pcnt > qcnt)
                { printf("\r    Completed %3d%%",pcnt);
                  fflush(stdout);
                }
              qcnt = pcnt;
            }

          //  skip remainder of cache and T2 entries < T1->cpre

          bidx = 0;
          for (cp = vhgh; cp < ctop; cp += KBYTE)
            bidx += cp[CBYTE];
          for (cpre = T1->cpre; T2->cpre < cpre; Next_Kmer_Entry(T2))
            bidx += T2->csuf[CBYTE];
          JumpTo_Post_Index(P2,bidx);

#ifdef DEBUG_MERGE
          Tdp = T2->cidx;
          printf("Loading %lld %06x ...",Tdp,cpre); fflush(stdout);
#endif

          //  load cahce with T2 entries = T1->cpre

          for (cp = cache; T2->cpre == cpre; cp += KBYTE)
            { memcpy(cp,T2->csuf,KBYTE);
              Next_Kmer_Entry(T2);
            }
          ctop = cp;
          ctop[LBYTE] = 11;

          //  if cache is empty then skip to next T1 entry with a greater prefix than cpre

          if (ctop == cache)
            { bidx = 0;
              while (T1->cpre == cpre)
                { bidx += T1->csuf[CBYTE];
                  Next_Kmer_Entry(T1);
                }
              JumpTo_Post_Index(P1,bidx);
#ifdef DEBUG_MERGE
              printf(" ... Empty => to %06x in T1\n",T1->cpre);
#endif
              continue;
            }

          //  start adpatermer merge for prefix cpre

          plen = 12;
          vlcp[plen] = rcur = rend = cache;
          vlow  = cache-KBYTE;
          vhgh  = cache;
          pdx   = POST_BUF_MASK;
          cdx   = 0;
          eorun = 0;

#ifdef DEBUG_MERGE
          printf("... to %lld rcur = rend = %lld, eorunn = 0, plen = 12\n",
                 T2->cidx,Tdp+(rcur-cache)/KBYTE);
          fflush(stdout);
#endif
        }

#define ADVANCE(l)					\
{ if (l >= vhgh)					\
    { int n;						\
							\
      for (n = l[CBYTE]; n > 0; n--)			\
        { pdx = (pdx+1) & POST_BUF_MASK;		\
          Current_Post(P2,(uint8 *) (post+pdx));	\
          Next_Post_Entry(P2);				\
        }						\
      vhgh = l+KBYTE;					\
    }							\
  cdx = (cdx + l[CBYTE]) & POST_BUF_MASK;		\
  l += KBYTE;						\
}

      // eorun = 0: rcur <= rend, n[1..plen] = rcur..rend, n[plen+1] < rend[plen+1]
      // eorun = 1: rcur <  rend, n[1..plen] = rcur..rend-1, lcp(rend) < plen 

      else
         { int nlcp;

           nlcp = suf1[LBYTE];
           if (nlcp > plen)
             goto pairs;
           else if (nlcp == plen)
             { if (eorun)
                 goto pairs;
             }
           else
             { if ( ! eorun)
                 ADVANCE(rend)
               while (rend[LBYTE] > nlcp)
                 ADVANCE(rend)
               plen = rend[LBYTE];
               if (plen < nlcp)
                 { eorun = 1;
                   plen  = nlcp;
                   goto pairs;
                 }
               eorun = 0;
               rcur  = rend;
             }
         }

       while (plen < KMER)
         { int h, m, c, d;

           h = cbyte[plen];
           m = mbyte[plen];
           c = suf1[h] & m;
           for (d = rend[h]&m; d < c; d = rend[h]&m)
             { ADVANCE(rend)
               if (rend[LBYTE] < plen)
                 { eorun = 1;
                   goto pairs;
                 }
             }
           if (d > c)
             goto pairs;
           plen += 1;
           vlcp[plen] = rcur = rend;
         }
       ADVANCE(rend)
       eorun = 1;

       //  Get pairs;

    pairs:

#ifdef DEBUG_MERGE
      printf("-> %d[%lld,%lld] %d",plen,Tdp+(vlcp[plen]-cache)/KBYTE,Tdp+(rend-cache)/KBYTE,eorun);
      printf("  [%lld,%lld] %d",Tdp+(vlow-cache)/KBYTE,Tdp+(vhgh-cache)/KBYTE,pdx);
      fflush(stdout);
#endif

      { int       freq, lcs, udx;
        int       asign, abuck, adest;
        IOBuffer *ou;
        uint8    *l, *vcp, *jptr, *btop;
        int       m, n, k, b;
        
        freq = 0;
        vcp = vlcp[plen];
        if (vcp <= vlow)
          {
#ifdef DEBUG_MERGE
            printf("   vlow <= vcp\n");
            fflush(stdout);
#endif
            goto empty;
          }
      
        for (l = rend-KBYTE; l >= vcp; l -= KBYTE)
          { freq += l[CBYTE];
            if (freq >= FREQ)
              { vlow = l;
#ifdef DEBUG_MERGE
                printf("   %d vlow = %lld\n",freq,Tdp+(l-cache)/KBYTE);
                fflush(stdout);
#endif
                goto empty;
              }
          }
        lcs = freq;
        l   = rend;
        if ( ! eorun)
          { udx = cdx;
            l = rend;
            freq += l[CBYTE];
            if (freq >= FREQ)
              {
#ifdef DEBUG_MERGE
                printf("   %d too high at %lld\n",freq,Tdp+(l-cache)/KBYTE);
                fflush(stdout);
#endif
                goto empty;
              }
            ADVANCE(l)
            while (l[LBYTE] >= plen)
              { freq += l[CBYTE];
                if (freq >= FREQ)
                  {
#ifdef DEBUG_MERGE
                    printf("   %d too high at %lld\n",freq,Tdp+(l-cache)/KBYTE);
                    fflush(stdout);
#endif
                    cdx = udx;
                    goto empty;
                  }
                ADVANCE(l)
              }
            cdx = udx;
          }
#ifdef DEBUG_MERGE
        printf("    [%lld,%lld) w %d posts\n",Tdp+(vcp-cache)/KBYTE,Tdp+(l-cache)/KBYTE,freq);
        fflush(stdout);
#endif

        if (cdx >= lcs)
          b = cdx-lcs;
        else
          b = (cdx+POST_BUF_LEN) - lcs;
        if (b + freq > POST_BUF_LEN)
          { m = (b+freq) & POST_BUF_MASK;
            for (m--; m >= 0; m--)
              post[POST_BUF_LEN+m] = post[m];
          }

        nhits += suf1[CBYTE] * freq;
        g1len += suf1[CBYTE];

        for (n = suf1[CBYTE]; n > 0; n--)
          { Current_Post(P1,aptr);
            asign = (aptr[ISIGN] & 0x80);
            aptr[ISIGN] &= 0x7f;
            abuck = (apost >> ESHIFT);
            adest = Select[abuck];
            jptr  = (uint8 *) (post+b);
            for (k = 0; k < freq; k++)
              { if (asign == (jptr[JSIGN] & 0x80))
                  ou = nunit + adest;
                else
                  ou = cunit + adest;
                btop = ou->btop;
                *btop++ = plen;
                memcpy(btop,aptr,IBYTE);
                btop += IBYTE;
                memcpy(btop,jptr,JBYTE);
                btop += JBYTE;

                ou->buck[abuck] += 1;

#ifdef DEBUG_MERGE
                if (n == suf1[CBYTE])
                  { int64 ip;
                    int   ss;

                    ss = (jptr[JSIGN] & 0x80);
                    jptr[JSIGN] &= 0x7f;

                    printf("      %ld: %c",((int64 *) jptr)-post,ss?'-':'+');
                    ip = 0;
                    memcpy((uint8 *) (&ip),jptr+JPOST,JCONT);
                    printf(" %4lld",ip);
                    ip = 0;
                    memcpy((uint8 *) (&ip),jptr,JPOST);
                    printf(" %9lld\n",ip);
                    fflush(stdout);

                    if (ss)
                      jptr[JSIGN] |= 0x80;
                  }
#endif

                if (btop >= ou->bend)
                  { write(ou->file,ou->bufr,btop-ou->bufr);
                    ou->btop = ou->bufr;
                  }
                else
                  ou->btop = btop;

                jptr += sizeof(int64);
              }
#ifdef DEBUG_MERGE
            { int64 ip;

              if (n == suf1[CBYTE])
                printf("   vs\n");
              printf("      %lld: %c",P1->cidx,asign?'-':'+');
              ip = 0;
              memcpy((uint8 *) (&ip),aptr+IPOST,ICONT);
              printf(" %4lld",ip);
              ip = 0;
              memcpy((uint8 *) (&ip),aptr,IPOST);
              printf(" %9lld\n",ip);
              fflush(stdout);
            }
#endif
            Next_Post_Entry(P1);
          }

        Next_Kmer_Entry(T1);
        continue;
      }

    empty:
      JumpTo_Post_Index(P1,(int64) suf1[CBYTE]);
      Next_Kmer_Entry(T1);
    }

  { int j;

    for (j = 0; j < NTHREADS; j++)
      { if (nunit[j].btop > nunit[j].bufr)
          write(nunit[j].file,nunit[j].bufr,nunit[j].btop-nunit[j].bufr);
        close(nunit[j].file);
        if (cunit[j].btop > cunit[j].bufr)
          write(cunit[j].file,cunit[j].bufr,cunit[j].btop-cunit[j].bufr);
        close(cunit[j].file);
      }
  }

  parm->nhits = nhits;
  parm->g1len = g1len;
  return (NULL);
}
  

static void adaptamer_merge(char *g1,        char *g2,
                            Kmer_Stream *T1, Kmer_Stream *T2,
                            Post_List *P1,   Post_List *P2)
{ SP         parm[NTHREADS];
#ifndef DEBUG_MERGE
  pthread_t  threads[NTHREADS];
#endif
  uint8     *cache;
  int64      nhits, g1len;
  int        i, k;

  if (VERBOSE)
    { fprintf(stdout,"  Starting adaptamer merge\n");
      fflush(stdout);
    }

  parm[0].T1 = T1;
  parm[0].T2 = T2;
  parm[0].P1 = P1;
  parm[0].P2 = P2;
  for (i = 1; i < NTHREADS; i++)
    { parm[i].T1 = Clone_Kmer_Stream(T1);
      parm[i].T2 = Clone_Kmer_Stream(T2);
      parm[i].P1 = Open_Post_List(g1);
      parm[i].P2 = Open_Post_List(g2);
    }

  cache = Malloc(NTHREADS*(P2->maxp+1)*KBYTE,"Allocating cache");
  if (cache == NULL)
    exit (1);

  for (i = 0; i < NTHREADS; i++)
    { IOBuffer *nu, *cu;

      parm[i].tid   = i;
      parm[i].cache = cache + i * (P2->maxp+1) * KBYTE;
      parm[i].nunit = nu = N_Units + i * NTHREADS;
      parm[i].cunit = cu = C_Units + i * NTHREADS;
      for (k = 0; k < NTHREADS; k++)
        { nu[k].file = open(nu[k].name,O_WRONLY|O_CREAT|O_TRUNC,S_IRWXU);
          if (nu[k].file < 0)
            { fprintf(stderr,"%s: Cannot open %s for reading\n",Prog_Name,nu[k].name);
              exit (1);
            }
          cu[k].file = open(cu[k].name,O_WRONLY|O_CREAT|O_TRUNC,S_IRWXU);
          if (cu[k].file < 0)
            { fprintf(stderr,"%s: Cannot open %s for reading\n",Prog_Name,cu[k].name);
              exit (1);
            }
        }
      bzero(nu[0].buck,sizeof(int64)*NBUCKS);
      bzero(cu[0].buck,sizeof(int64)*NBUCKS);
    }

#ifdef DEBUG_MERGE
  for (i = 0; i < NTHREADS; i++)
    merge_thread(parm+i);
#else
  for (i = 1; i < NTHREADS; i++)
    pthread_create(threads+i,NULL,merge_thread,parm+i);
  merge_thread(parm);

  for (i = 1; i < NTHREADS; i++)
    pthread_join(threads[i],NULL);
#endif

  if (VERBOSE)
    { printf("\r    Completed 100%%\n");
      fflush(stdout);
    }
   
  free(cache);

  for (i = NTHREADS-1; i >= 0; i--)
    { Free_Kmer_Stream(parm[i].T1);
      Free_Kmer_Stream(parm[i].T2);
      Free_Post_List(parm[i].P1);
      Free_Post_List(parm[i].P2);
    }

  nhits = g1len = 0;
  for (i = 0; i < NTHREADS; i++)
    { nhits += parm[i].nhits;
      g1len += parm[i].g1len;
    }

  if (VERBOSE)
    printf("\n  Total seeds = %lld,  per G1 position = %.1f\n\n",nhits,(1.*nhits)/g1len);
}



/***********************************************************************************************
 *
 *   PAIR RE-IMPORT AND SORT
 *
 **********************************************************************************************/

typedef struct
  { int       in;
    int       swide;
    int       comp;
    DAZZ_DB  *DB1;
    DAZZ_DB  *DB2;
    int64    *buck;
    uint8    *buffer;
    uint8    *sarr;
    Range    *range;
  } RP;

static void *reimport_thread(void *args)
{ RP *parm = (RP *) args;
  int    swide  = parm->swide;
  int    in     = parm->in;
  int    comp   = parm->comp;
  uint8 *sarr   = parm->sarr;
  uint8 *bufr   = parm->buffer;
  int64 *buck   = parm->buck;

  DAZZ_READ *jreads = parm->DB2->reads;

  int64  ipost, jpost, icont, jcont, pdiag;
  uint8 *_ipost = (uint8 *) (&ipost);
  uint8 *_jpost = (uint8 *) (&jpost);
  uint8 *_icont = (uint8 *) (&icont);
  uint8 *_jcont = (uint8 *) (&jcont);
  uint8 *_pdiag  = (uint8 *) (&pdiag);

  uint8 *x;
  int    iolen, iunit, lcp, flip;
  int64  drem, flag, mask;
  uint8 *bend, *btop, *b;

  iolen = 2*NTHREADS*1000000;
  iunit = IBYTE + JBYTE + 1;

  bend = bufr + read(in,bufr,iolen);
  if (bend-bufr < iolen)
    btop = bend;
  else
    btop = bend-iunit;
  b = bufr;

  ipost = 0;
  jpost = 0;
  icont = 0;
  jcont = 0;

  flag = (0x1ll << (8*JCONT-1));
  mask = flag-1;

  while (1)
    { lcp = *b++;
      memcpy(_ipost,b,IPOST);
      b += IPOST;
      memcpy(_icont,b,ICONT);
      b += ICONT;
      memcpy(_jpost,b,JPOST);
      b += JPOST;
      memcpy(_jcont,b,JCONT);
      b += JCONT;
      flip = ((jcont & flag) != 0);
      jcont &= mask;

      x = sarr + swide * buck[icont >> CSHIFT]++;
      *x++ = lcp;
      if (comp)
        { drem = ipost + jpost;
          if (flip)
            ; // ??? 
        }
      else
        { drem = (ipost - jpost) + jreads[jcont].rlen;
          if (flip)
            ipost += (KMER-lcp);
        }
      pdiag = (drem >> 6);
      *x++ = drem-(pdiag<<6);

      memcpy(x,_ipost,IPOST);
      x += IPOST;
      memcpy(x,_pdiag,DBYTE);
      x += DBYTE;
      memcpy(x,_jcont,JCONT);
      x += JCONT;
      memcpy(x,_icont,ICONT);
      x += ICONT;
      x[-1] = 0;

      if (b >= btop)
        { int ex = bend-b;
          memcpy(bufr,b,ex);
          bend = bufr+ex;
          bend += read(in,bend,iolen-ex);
          if (bend == bufr)
            break;
          if (bend-bufr < iolen)
            btop = bend;
          else
            btop = bend-iunit;
          b = bufr;
        }
    }

  close(in);

  return (NULL);
}

void print_seeds(uint8 *sarray, int swide, Range *range, int64 *panel,
                 DAZZ_DB *DB1, DAZZ_DB *DB2, int comp)
{ uint8 *e, *x;
  int    n, p;
  int    lcp, drm;

  int64  imask, itops;
  int64  ipost, dbuck, jcont, icont;
  int64  jpost, diag;
  uint8 *_ipost = (uint8 *) (&ipost);
  uint8 *_dbuck = (uint8 *) (&dbuck);
  uint8 *_jcont = (uint8 *) (&jcont);
  uint8 *_icont = (uint8 *) (&icont);

  ipost = 0;
  dbuck = 0;
  jcont = 0;
  icont = 0;

  (void) DB1;

  imask = (0xffll << ((ICONT-1)<<3));

  for (n = 0; n < NTHREADS; n++)
    { x = sarray + range[n].off;
      for (p = range[n].beg; p < range[n].end; p++)
        { itops = (p<<CSHIFT) & imask;
          e = x + panel[p];
          while (x < e)
            { lcp = *x++;
              drm = *x++;
              memcpy(_ipost,x,IPOST);
              x += IPOST;
              memcpy(_dbuck,x,DBYTE);
              x += DBYTE;
              memcpy(_jcont,x,JCONT);
              x += JCONT;
              memcpy(_icont,x,ICONT-1);
              icont |= itops;
              x += ICONT;

              if (comp)
                { diag  = (dbuck<<6)+drm;
                  jpost = diag-ipost;
                }
              else
                { diag  = ((dbuck<<6)+drm) - DB2->reads[jcont].rlen;
                  jpost = ipost-diag;
                }

             if (jpost < 0 || jpost > DB2->reads[jcont].rlen)
               printf("SHOUT OUT\n");

              printf("  %10ld:  %5lld %5lld: %8lld  %10lld x %10lld  (%2d)  %2d\n",
                     (x-sarray)/swide,icont,jcont,diag,ipost,jpost,drm,lcp);
            }
        }
    }
}

/*
static void print_seq(char *seq, int b, int e)
{ static int toA[5] = { 'a', 'c', 'g', 't', '*' };
  int j;

  for (j = b; j < e; j++)
    printf("%c",toA[(int) seq[j]]);
  printf("\n");
}
*/

typedef struct

  { DAZZ_DB    *DB1, *DB2;
    int         lmax;           //  dynamic list for adjacent bucket merges
    uint8     **list;
    FILE       *ofile;
    int64       nhits;
                            //  See align.h for doc on the following:
    Work_Data  *work;           //  work storage for alignment module
    Align_Spec *spec;           //  alignment spec
    Alignment   align;          //  alignment record
    Overlap     ovl;            //  overlap record

  } Contig_Bundle;

//  [beg,end) in the sorted array of width swide elements contain all the adaptamer seeds between
//    the contigs in the parameter pair.  Look for seed chains in each pair of diagaonl buckets
//    of sufficient score, and when found search for an alignment, outputing it if found.

void align_contigs(uint8 *beg, uint8 *end, int swide, int ctg1, int ctg2, Contig_Bundle *pair)
{ int     lmax = pair->lmax;
  uint8 **list = pair->list;

  Overlap    *ovl   = &(pair->ovl);
  int         comp  = (ovl->flags != 0);
#ifdef CALL_ALIGNER
  Work_Data  *work  = pair->work;
  Align_Spec *spec  = pair->spec;
  Alignment  *align = &(pair->align);
#ifndef DEBUG_HIT
  FILE       *ofile = pair->ofile;
#endif
#endif

  uint8 *b, *m, *e;

  int64  nhit, alen, blen;
  int64  first_value;

  int    new, aux;
  int64  ndiag, cdiag;
  uint8 *_ndiag = (uint8 *) (&ndiag);

  int64  ipost, apost, mpost;
  uint8 *_ipost = (uint8 *) (&ipost);
  uint8 *_apost = (uint8 *) (&apost);
  uint8 *_mpost = (uint8 *) (&mpost);

  ndiag = 0;
  ipost = 0;
  apost = 0;
  mpost = 0;

  blen   = pair->DB2->reads[ctg2].rlen;
  alen   = pair->DB1->reads[ctg1].rlen;
  nhit   = 0;

#ifdef DEBUG_HIT
  if (comp)
    first_value = 0x7fffffffffffffffll;
  else
    first_value = -1;
#else
  first_value = -1;
#endif

  //  Find segments b,m,e such that b > m and diag is cdiag for elements [b,m) and
  //    cdiag+1 for elements [m,e) (if m < e)
  //  If m == e (i.e. !aux) and b,m = m',e' of previous find (i.e. !new) then don't examine
  //    as the chain for this triple is subset of the chain for the previous triple.

  b = e = beg + (IPOST+2);
  memcpy(_ndiag,e,DBYTE);
  cdiag = ndiag;
  while (ndiag == cdiag && e < end)
    { e += swide;
      memcpy(_ndiag,e,DBYTE);
    }

#if defined(DEBUG_SEARCH) || defined(DEBUG_HIT)
  printf("\n");
#endif

  while (1)
    { m = e;
      aux = 0;
      while (ndiag == cdiag+1 && e < end)
        { e += swide;
          memcpy(_ndiag,e,DBYTE);
          aux = 1;
        }

      if (new || aux)
        { int    go, lcp, mix;
          int64  lps, cov, npost;
          uint8 *s, *t;
          int    len, lst;
     
#ifdef DEBUG_SEARCH
          printf("Diag %lld",cdiag);
          if (aux)
            printf("+1");
          printf("\n");
#endif

          //  Have triple b,m,e, b > m, to examine.  Capture the ipost-ordered merge of [b,m) and
          //    [m,e) in list[0..len) and process any above-threshold chains encountered while
          //    doing the merge.

          if (e-b > lmax)
            { lmax = (e-b)*1.2+100;
              list = Realloc(list,(lmax+1)*sizeof(uint8 *),"Expanding merge index");
              if (list == NULL)
                exit (1);
            }

          e -= IPOST;
          m -= IPOST;

          s = b-IPOST;
          memcpy(_ipost,s,IPOST);
          t = m; 
          if (aux)
            memcpy(_apost,t,IPOST);
          else
            apost = MAX_INT64;
          if (apost < ipost)
            { cov = t[-2];
              lps = apost + cov;
#ifdef DEBUG_SEARCH
              npost = apost;
#endif
              list[0] = t;
              t += swide;
              if (t >= e)
                apost = MAX_INT64;
              else
                memcpy(_apost,t,IPOST);
              mix = 0x2;
            }
          else
            { cov = s[-2];
              lps = ipost + cov;
#ifdef DEBUG_SEARCH
              npost = ipost;
#endif
              list[0] = s;
              s += swide;
              if (s >= m)
                ipost = MAX_INT64;
              else
                memcpy(_ipost,s,IPOST);
              mix = 0x1;
            }
          lst = 0;

#ifdef DEBUG_SEARCH
          { uint8 *n = list[0];
            int64  dg;

            dg = ((cdiag<<6) + n[-1]);
            if (n >= m)
              dg += 64;
            if (comp)
              printf("   %c %10ld: %10lld x %10lld %2d %4lld (%d)\n",
                     n<m?'.':'+',(n-beg)/swide,npost,dg-npost,n[-2],cov,n[-1]);
            else
              printf("   %c %10ld: %10lld x %10lld %2d %4lld (%d)\n",
                     n<m?'.':'+',(n-beg)/swide,npost,npost-(dg-blen),n[-2],cov,n[-1]);
          }
#endif

          go = 1;
          for (len = 1; go; len++)
            { if (apost < ipost)
                { lcp = t[-2];
                  npost = apost;
                  list[len] = t;
                  t += swide;
                  if (t >= e)
                    apost = MAX_INT64;
                  else
                    memcpy(_apost,t,IPOST);
                  mix |= 0x2;
                }
              else
                { lcp = s[-2];
                  npost = ipost;
                  list[len] = s;
                  s += swide;
                  if (s >= m)
                    { if (s > m)
                        go = 0;
                      else
                        ipost = MAX_INT64;
                    }
                  else
                    memcpy(_ipost,s,IPOST);
                  mix |= 0x1;
                }
  
              if (npost >= lps + CHAIN_BREAK)
                { if (cov >= CHAIN_MIN && (mix != 1 || new))

                    //  Have a chain that covers CHAIN_MIN or more bases of the A-sequence:

                    { uint8 *n;
                      int    k;
                      int64  jcov;

                      nhit += 1;
#ifdef DEBUG_SEARCH
                      printf("                  Process\n");
#endif
#ifdef DEBUG_HIT
                      printf("Hit %lld",cdiag);
                      if (aux)
                        printf("+1");
                      printf(" %lld %d\n",cov,len-lst);
#endif

                      //  Check that also cover CHAIN_MIN or more bases of the B-sequence

                      { int64 jlps;
                        int64 dg, jcps;

                        jlps = 0;
                        jcov = 0;
                        for (k = lst; k < len; k++)
                          { n = list[k];
                            memcpy(_mpost,n,IPOST);
                            lcp = n[-2];
                            dg  = n[-1];
                            if (n >= m)
                              dg += 64;
                            mpost = mpost - dg;
                            jcps = mpost + lcp;
                            if (jcps > jlps)
                              { if (mpost >= jlps)
                                  jcov += lcp;
                                else
                                  jcov += jcps-jlps;
                                jlps = jcps;
                              }
                          }
#ifdef DEBUG_HIT
                        printf("  J-coverage = %lld\n",jcov);
#endif
                      }

		      if (jcov >= CHAIN_MIN)
                        { int    dg, lg;
                          int64  fp, lp;
                          int64  alast;

                          //  Filter passed, now search for local alignments for each
                          //    reduced seed match (several adaptemer seeds that overlap)

                          //  Fetch contig sequences if not already loaded
#ifdef CALL_ALIGNER
                          alast = first_value;
                          if (ctg1 != ovl->aread)
                            { Load_Read(pair->DB1,ctg1,align->aseq,0);
                              align->alen = pair->DB1->reads[ctg1].rlen;
                              ovl->aread = ctg1;
                              if (comp)
                                Complement_Seq(align->aseq,align->alen);
#ifdef DEBUG_HIT
                              printf("Loading A = %d%c\n",ctg1,comp?'c':'n');
#endif
                            }
                          if (ctg2 != ovl->bread)
                            { Load_Read(pair->DB2,ctg2,align->bseq,0);
                              align->blen = pair->DB2->reads[ctg2].rlen;
                              ovl->bread = ctg2;
#ifdef DEBUG_HIT
                              printf("Loading B = %dn\n",ctg2);
#endif
                            }
#endif

                          //  Scan list reducing overlapping seeds, and for each look for
                          //    a local alignment

                          n = list[lst];
                          memcpy(_mpost,n,IPOST);
                          fp = mpost;
                          lp = mpost + n[-2];
                          if (n < m)
                            lg = n[-1];
                          else
                            lg = n[-1] + 64;
                          for (k = lst+1; k <= len; k++)
                            { if (k == len)
                                dg = -1;
                              else
                                { n = list[k];
                                  memcpy(_mpost,n,IPOST);
                                  if (n < m)
                                    dg = n[-1];
                                  else
                                    dg = n[-1] + 64;
                                }
                              if (dg == lg && mpost <= lp)
                                { if (mpost + n[-2] > lp)
                                    lp = mpost + n[-2];
                                }
                              else
                                { int mo;

                                  //  Have a reduced seed at fp,lg of length lp-fp
#ifdef DEBUG_HIT
                                  printf("  %10ld:  %c %10lld %2lld [%d]\n",
                                         (list[k-1]-beg)/swide,(list[k-1]<m)?'.':'+',fp,lp-fp,lg);
                                  fflush(stdout);
#endif
#ifdef CALL_ALIGNER
                                  if (comp)
#ifdef DEBUG_HIT
                                    { lg += (cdiag<<6);
                                      fp = alen - (fp + KMER);
                                      if ((mo = (fp < alast)))
                                        { lg = alen - (lg + KMER);
                                          align->flags = 0;
#else
                                    { if ((mo = (fp > alast)))
                                        { lg += (cdiag<<6);
                                          fp = alen - (fp + KMER);
                                          lg = alen - (lg + KMER);
                                          align->flags = ACOMP_FLAG;
#endif
                                        }
                                    }
                                  else
                                    { if ((mo = (fp > alast)))
                                        { lg += (cdiag<<6) - blen;
                                          align->flags = 0;
                                        }
                                    }
                                  if (mo)
                                    { Local_Alignment(align,work,spec,lg,lg,2*fp-lg,-1,-1);
                                      if (align->path->aepos - align->path->abpos >= CHAIN_MIN)
#ifdef DEBUG_HIT
                                        { printf("Local %d: %d-%d vs %d %d\n",k-lst,
                                                 align->path->abpos,align->path->aepos,
                                                 align->path->bbpos,align->path->bepos);
                                          Compute_Trace_PTS(align,work,TSPACE,GREEDIEST);
                                          Print_Alignment(stdout,align,work,4,80,10,0,8);
                                          fflush(stdout);
                                        }
                                      else
                                        printf("Not found, len = %d\n",
                                               align->path->aepos-align->path->abpos);
                                      if (comp)
                                        alast = align->path->abpos;
                                      else
                                        alast = align->path->aepos;
#else
                                        { if (ABYTE)
                                            Compress_TraceTo8(ovl,0);
                                          if (Write_Overlap(ofile,ovl,TBYTES))
                                            { fprintf(stderr,"%s: Cannot write output\n",Prog_Name);
                                              exit (1);
                                            }
                                        }
                                      alast = align->path->aepos;
#endif
                                    }
#endif

                                  fp = mpost;
                                  lg = dg;
                                  lp = mpost + n[-2];
                                }
                            }
                        }

                    }
#ifdef DEBUG_SEARCH
                  else
                    printf("                  Break\n");
#endif
                  if (go)
                    { cov = lcp;
                      lps = npost + lcp;
                      lst = len;
                      mix = 0;
                    }
                }
              else
                { int64 cps;

                  cps = npost + lcp;
                  if (cps > lps)
                    { if (npost >= lps)
                        cov += lcp;
                      else
                        cov += cps-lps;
                      lps = cps;
                    }
                }
#ifdef DEBUG_SEARCH
              if (go)
                { uint8 *n = list[len];
                  int64  dg;

                  dg = ((cdiag<<6) + n[-1]);
                  if (n >= m)
                    dg += 64;
                  if (comp)
                    printf("   %c %10ld: %10lld x %10lld %2d %4lld (%d)\n",
                           n<m?'.':'+',(n-beg)/swide,npost,dg-npost,n[-2],cov,n[-1]);
                  else
                    printf("   %c %10ld: %10lld x %10lld %2d %4lld (%d)\n",
                           n<m?'.':'+',(n-beg)/swide,npost,npost-(dg-blen),n[-2],cov,n[-1]);
                }
#endif
            }

          e += IPOST;
          m += IPOST;

          ipost = apost = 0;
        }

      if (e >= end) break;

      if (aux)
        { b = m;
          cdiag += 1;
          new = 0;
        }
      else
        { b = e;
          cdiag = ndiag;
          while (ndiag == cdiag && e < end)
            { e += swide;
              memcpy(_ndiag,e,DBYTE);
            }
          new = 1;
        }
    }

  if (nhit > 0)
    { printf("%d x %d: %lld\n",ctg1,ctg2,nhit);
      fflush(stdout);
    }

  pair->lmax   = lmax;
  pair->list   = list;
  pair->nhits += nhit;
}


typedef struct
  { int       swide;
    int       comp;
    int64    *panel;
    uint8    *sarr;
    Range    *range;
    DAZZ_DB   DB1;
    DAZZ_DB   DB2;
    FILE     *ofile;
  } TP;

static void *search_seeds(void *args)
{ TP *parm = (TP *) args;
  int      swide  = parm->swide;
  int      comp   = parm->comp;
  int64   *panel  = parm->panel;
  uint8   *sarray = parm->sarr;
  Range   *range  = parm->range;
  int      beg    = range->beg;
  int      end    = range->end;
  DAZZ_DB *DB1    = &(parm->DB1);
  DAZZ_DB *DB2    = &(parm->DB2);
  int      iless  = ICONT-1;
  int      foffs  = swide-ICONT;
  FILE    *ofile  = parm->ofile;

  int64  imask, itops;
  int64  icrnt, jcrnt;
  int64  inext, jnext;
  uint8 *_inext = (uint8 *) (&inext);
  uint8 *_jnext = (uint8 *) (&jnext);

  Contig_Bundle _pair, *pair = &_pair;
  int           tspace;

  int    o;
  uint8 *x, *e, *y, *b;

  imask = (0xffll << ((ICONT-1)<<3));
  inext = 0;
  jnext = 0;

  pair->lmax = 1000;
  pair->list = Malloc(pair->lmax*sizeof(uint8 *),"Allocating merge index");
  if (pair->list == NULL)
    exit (1);
  pair->DB1 = DB1;
  pair->DB2 = DB2;
  pair->align.aseq = New_Read_Buffer(DB1);
  pair->align.bseq = New_Read_Buffer(DB2);
  pair->align.path = &(pair->ovl.path);
  if (comp)
    pair->ovl.flags = COMP_FLAG;
  else
    pair->ovl.flags = 0;
  pair->ovl.aread = -1;
  pair->ovl.bread = -1;
  pair->work = New_Work_Data();
  pair->spec = New_Align_Spec(.7,100,DB1->freq,0);
  pair->ofile = ofile;
  pair->nhits = 0;

  fwrite(&(pair->nhits),sizeof(int64),1,ofile);
  tspace = 100;
  fwrite(&tspace,sizeof(int),1,ofile);

  x = sarray + range->off;
  for (o = beg; o < end; o++)
    { itops = (o<<CSHIFT) & imask;

      y = x+foffs;
      memcpy(_inext,y,iless);
      _inext[iless] = itops;
      y -= JCONT;
      memcpy(_jnext,y,JCONT);
      icrnt = inext;
      jcrnt = jnext;

      e = x + panel[o];
      for (b = x; x < e; x += swide)
        { y = x+foffs;
          memcpy(_inext,y,iless);
          inext |= itops;
          y -= JCONT;
          memcpy(_jnext,y,JCONT);
          if (inext != icrnt || jnext != jcrnt)
            { align_contigs(b,x,swide,(int) icrnt,(int) jcrnt,pair);
              icrnt = inext;
              jcrnt = jnext;
              b = x;
            }
        }
      align_contigs(b,x,swide,icrnt,jcrnt,pair);
    }

  Free_Align_Spec(pair->spec);
  Free_Work_Data(pair->work);
  free(pair->align.aseq-1);
  free(pair->align.bseq-1);
  free(pair->list);

  rewind(ofile);
  fwrite(&(pair->nhits),sizeof(int64),1,ofile);
  fclose(ofile);

  return (NULL);
}

static void pair_sort_search(DAZZ_DB *DB1, DAZZ_DB *DB2)
{ uint8 *sarray;
  int    swide;
  int64  nels;

  RP     rarm[NTHREADS];
  TP     tarm[NTHREADS];
#ifndef DEBUG_SORT
  pthread_t threads[NTHREADS];
#endif
  int64    *panel;
  Range     range[NTHREADS];

  IOBuffer *unit[2], *nu;
  int       nused;
  int       i, p, j, u;

  if (VERBOSE)
    { fprintf(stdout,"  Starting seed sort and alignment search, %d parts\n",2*NTHREADS);
      fflush(stdout);
    }

  unit[0] = N_Units;
  unit[1] = C_Units;

  { int64 cum, nelmax;

    nelmax = 0;
    for (u = 0; u < 2; u++)
      { cum = 0;
        nu = unit[u];

        for (j = 0; j < NBUCKS; j++)
          { for (i = 0; i < NTHREADS; i++)
              { cum += nu[i].buck[j];
                nu[i].buck[j] = cum;
              }
            if (j+1 == NBUCKS || Select[j] != Select[j+1])
              { if (cum > nelmax)
                  nelmax = cum;
                cum = 0;
              }
          }

        for (j = NBUCKS-1; j >= 0; j--)
          { for (i = NTHREADS-1; i >= 1; i--)
              nu[i].buck[j] = nu[i-1].buck[j];
            if (j == 0 || Select[j] != Select[j-1])
              nu[0].buck[j] = 0;
            else
              nu[0].buck[j] = nu[NTHREADS-1].buck[j-1];
          }
      }

    swide  = IBYTE + DBYTE + JCONT + 2;
    sarray = Malloc((nelmax+1)*swide,"Sort Array");
    panel  = Malloc(NBUCKS*sizeof(int64),"Bucket Array");
    if (sarray == NULL || panel == NULL)
      exit (1);
  }

  for (p = 0; p < NTHREADS; p++)
    { rarm[p].swide  = swide;
      rarm[p].sarr   = sarray;
      rarm[p].buffer = N_Units[p].bufr;   //  NB: Units have been transposed
      rarm[p].range  = range+p;
      rarm[p].DB1    = DB1;
      rarm[p].DB2    = DB2;

      tarm[p].swide  = swide;
      tarm[p].sarr   = sarray;
      tarm[p].panel  = panel;
      tarm[p].range  = range+p;
      tarm[p].DB1    = *DB1;
      tarm[p].DB2    = *DB2;
      if (p > 0)
        { tarm[p].DB1.bases = fopen(Catenate(DB1->path,"","",".bps"),"r");
          if (tarm[p].DB1.bases == NULL)
            { fprintf(stderr,"%s: Cannot open another copy of DB\n",Prog_Name);
              exit (1);
            }
          tarm[p].DB2.bases = fopen(Catenate(DB2->path,"","",".bps"),"r");
          if (tarm[p].DB2.bases == NULL)
            { fprintf(stderr,"%s: Cannot open another copy of DB\n",Prog_Name);
              exit (1);
            }
        }
    }

  for (u = 0; u < 2; u++)
   for (i = 0; i < NTHREADS; i++)
    { nu = unit[u] + i*NTHREADS;

      if (VERBOSE)
        { fprintf(stdout,"\r    Loading seeds for part %d  ",u*NTHREADS+i+1);
          fflush(stdout);
        }

      for (p = 0; p < NTHREADS; p++)
        { rarm[p].in = open(nu[p].name,O_RDONLY);
          if (rarm[p].in < 0)
            { fprintf(stderr,"%s: Cannot open %s for reading\n",Prog_Name,nu[p].name);
              exit (1);
            }
          rarm[p].buck = nu[p].buck;
          rarm[p].comp = u;
        }

#ifdef DEBUG_SORT
      for (p = 0; p < NTHREADS; p++)
        reimport_thread(rarm+p);
#else
      for (p = 1; p < NTHREADS; p++)
        pthread_create(threads+p,NULL,reimport_thread,rarm+p);
      reimport_thread(rarm);
      for (p = 1; p < NTHREADS; p++)
        pthread_join(threads[p],NULL);
#endif

      for (p = 0; p < NTHREADS; p++)
        unlink(nu[p].name);

#ifdef DEBUG_SORT
      for (p = 0; p < NTHREADS; p++)
        printf("  %s",nu[p].name);
      printf("\n");
      for (j = 0; j < NBUCKS; j++)
        { printf(" %4d:",j);
          for (p = 0; p < NTHREADS; p++)
            printf(" %10lld",unit[u][p].buck[j]);
          printf("\n");
        }
#endif

      { int64 prev, next;

        bzero(panel,sizeof(int64)*NBUCKS);
        prev = 0;
        for (j = (IDBsplit[i]>>CSHIFT); j < (IDBsplit[i+1]>>CSHIFT); j++)
          { next = nu[NTHREADS-1].buck[j];
            panel[j] = (next - prev)*swide;
            prev = next;
          }
        nels = next;

#ifdef DEBUG_SORT
        for (p = 0; p < NBUCKS; p++)
          if (panel[p] > 0)
            printf(" %2d: %10lld %10lld\n",p,panel[p],panel[p]/swide);
#endif

        if (VERBOSE)
          { fprintf(stdout,"\r    Sorting seeds for part %d  ",u*NTHREADS+i+1);
            fflush(stdout);
          }

        nused = rmsd_sort(sarray,nels,swide,swide-2,NBUCKS,panel,NTHREADS,range);

#ifdef DEBUG_SORT
        print_seeds(sarray,swide,range,panel,DB1,DB2,u);
#endif
      }

      if (VERBOSE)
        { fprintf(stdout,"\r    Searching seeds for part %d",u*NTHREADS+i+1);
          fflush(stdout);
        }

      for (p = 0; p < nused; p++)
        { tarm[p].ofile = 
             fopen(Numbered_Suffix(ALGN_NAME,i*NTHREADS+p,(u==0)?".N.las":".C.las"),"w");
          tarm[p].comp = u;
        }

#if defined(DEBUG_SORT) || defined(DEBUG_SEARCH) || defined(DEBUG_HIT)
      for (p = 0; p < nused; p++)
        search_seeds(tarm+p);
#else
      for (p = 1; p < nused; p++)
        pthread_create(threads+p,NULL,search_seeds,tarm+p);
      search_seeds(tarm);
      for (p = 1; p < nused; p++)
        pthread_join(threads[p],NULL);
#endif
    }

  free(panel);
  free(sarray);

  for (p = 1; p < NTHREADS; p++)
    { fclose(tarm[p].DB1.bases);
      fclose(tarm[p].DB2.bases);
    }

  if (VERBOSE)
    fprintf(stdout,"\r    Done                        \n");
}


int main(int argc, char *argv[])
{ Kmer_Stream *T1, *T2;
  Post_List   *P1, *P2;
  DAZZ_DB _DB1, *DB1 = &_DB1;
  DAZZ_DB _DB2, *DB2 = &_DB2;
  char    *OUTP;

  //  Process options

  { int    i, j, k;
    int    flags[128];
    char  *eptr;

    ARG_INIT("Amerge");

    FREQ = -1;
    OUTP = NULL;

    j = 1;
    for (i = 1; i < argc; i++)
      if (argv[i][0] == '-')
        switch (argv[i][1])
        { default:
            ARG_FLAGS("v")
            break;
          case 'f':
            ARG_NON_NEGATIVE(FREQ,"maximum seed frequency");
            break;
          case 'o':
            OUTP = argv[i]+2;
            break;
        }
      else
        argv[j++] = argv[i];
    argc = j;

    VERBOSE = flags['v'];

    if (argc != 3 || FREQ < 0)
      { fprintf(stderr,"Usage: %s %s\n",Prog_Name,Usage);
        exit (1);
      }
  }

  T1 = Open_Kmer_Stream(argv[1]);
  T2 = Open_Kmer_Stream(argv[2]);
  
  P1 = Open_Post_List(argv[1]);
  P2 = Open_Post_List(argv[2]);

  if (Open_DB(argv[1],DB1) < 0)
    { fprintf(stderr,"%s: Cannot open Dazzler DB %s\n",Prog_Name,argv[1]);
      exit (1);
    }
  Trim_DB(DB1);

  if (Open_DB(argv[2],DB2) < 0)
    { fprintf(stderr,"%s: Cannot open Dazzler DB %s\n",Prog_Name,argv[1]);
      exit (1);
    }
  Trim_DB(DB2);

  KMER      = T1->kmer;
  NTHREADS  = P1->nsqrt;
  PAIR_NAME = Strdup(Numbered_Suffix("._pair.",getpid(),"."),"Allocating temp name");

  { char *r1, *r2;

    if (OUTP == NULL)
      { r1 = Root(argv[1],".dam");
        r2 = Root(argv[2],".dam");
        ALGN_NAME = Strdup(Catenate(r1,".",r2,""),"Allocating temp name");
        free(r2);
        free(r1);
      }
    else
      ALGN_NAME = Strdup(OUTP,"Allocating temp name");
  }

  if (P1->freq < FREQ)
    { fprintf(stderr,"%s: Genome index for %s cutoff %d < requested cutoff\n",
                     Prog_Name,argv[1],P1->freq);
      exit (1);
    }
  if (P2->freq < FREQ)
    { fprintf(stderr,"%s: Genome index for %s cutoff %d < requested cutoff\n",
                     Prog_Name,argv[2],P2->freq);
      exit (1);
    }
  if (T1->kmer != T2->kmer)
    { fprintf(stderr,"%s: Indices not made with the same k-mer size (%d vs %d)\n",
                     Prog_Name,T1->kmer,T2->kmer);
      exit (1);
    }

  IBYTE = P1->pbyte;
  ICONT = P1->cbyte;
  IPOST = IBYTE-ICONT;
  ISIGN = IBYTE-1;

  JBYTE = P2->pbyte;
  JCONT = P2->cbyte;
  JPOST = JBYTE-JCONT;
  JSIGN = JBYTE-1;

  KBYTE = T2->pbyte;
  CBYTE = T2->hbyte;
  LBYTE = CBYTE+1;
  if (IPOST > JPOST)
    DBYTE = IPOST;
  else
    DBYTE = JPOST;

  if (TSPACE < TRACE_XOVR)
    { ABYTE  = 1;
      TBYTES = sizeof(uint8);
    }
  else
    { ABYTE  = 0;
      TBYTES = sizeof(uint16);
    }

  { int64 npost, cum, t;   //  Compute DB split into NTHREADS parts
    int   p, r, x, n;

    CSHIFT = 0;
    NBUCKS = DB1->treads;
    while (NBUCKS >= 512)
      { CSHIFT += 1;
        NBUCKS /= 2;
      }
    if (DB1->treads % (1 << CSHIFT) > 0)
      NBUCKS += 1;

    IDBsplit = Malloc((NTHREADS+1)*sizeof(int),"Allocating DB1 partitions");
    Select   = Malloc(NBUCKS*sizeof(int),"Allocating DB1 partition");
    if (IDBsplit == NULL || Select == NULL)
      exit (1);

    npost = DB1->totlen;
    cum   = 0;
    IDBsplit[0] = 0;
    p = 0;
    r = 0;
    t = npost/NTHREADS;
    for (x = 0; x < NBUCKS; x++)
      { Select[x] = p;
        n = ((x+1) << CSHIFT);
        while (r < n)
          cum += DB1->reads[r++].rlen;
        if (cum >= t)
          { p += 1;
            IDBsplit[p] = r;
            t = (npost*(p+1))/NTHREADS;
          }
      }
    IDBsplit[NTHREADS] = DB1->treads;

    ESHIFT = CSHIFT + ((P1->pbyte - P1->cbyte) << 3);
  }

  { int    j, k;   // Setup temporary pair file IO buffers
    uint8 *buffer;
    int64 *bucks;

    N_Units = Malloc(NTHREADS*NTHREADS*sizeof(IOBuffer),"IO buffers");
    C_Units = Malloc(NTHREADS*NTHREADS*sizeof(IOBuffer),"IO buffers");
    buffer  = Malloc(2*NTHREADS*NTHREADS*1000000,"IO buffers");
    bucks   = Malloc(2*NTHREADS*NBUCKS*sizeof(int64),"IO buffers");
    if (N_Units == NULL || C_Units == NULL || buffer == NULL || bucks == NULL)
      exit (1);

    j = -1;
    for (k = 0; k < NTHREADS*NTHREADS; k++)
      { if (k % NTHREADS == 0)
          j += 1;
        N_Units[k].bufr = buffer + (2 * k) * 1000000; 
        C_Units[k].bufr = buffer + (2 * k + 1) * 1000000; 
        N_Units[k].name = Strdup(Numbered_Suffix(PAIR_NAME,k,".N"),"Temp file name");
        C_Units[k].name = Strdup(Numbered_Suffix(PAIR_NAME,k,".C"),"Temp file name");
        N_Units[k].buck = bucks + (2 * j) * NBUCKS; 
        C_Units[k].buck = bucks + (2 * j + 1) * NBUCKS; 
      }
  }

  adaptamer_merge(argv[1],argv[2],T1,T2,P1,P2);

  { IOBuffer u;      //  Transpose unit matrix
    int      k, j;

    for (k = 0; k < NTHREADS; k++)
      for (j = k+1; j < NTHREADS; j++)
        { u = N_Units[j*NTHREADS+k];
          N_Units[j*NTHREADS+k] = N_Units[k*NTHREADS+j];
          N_Units[k*NTHREADS+j] = u;
          u = C_Units[j*NTHREADS+k];
          C_Units[j*NTHREADS+k] = C_Units[k*NTHREADS+j];
          C_Units[k*NTHREADS+j] = u;
        }
  }

  pair_sort_search(DB1,DB2);

  { int k;

    for (k = NTHREADS*NTHREADS-1; k >= 0; k--)
      { free(C_Units[k].name);
        free(N_Units[k].name);
      }
    free(N_Units->buck);
    free(N_Units->bufr);
    free(C_Units);
    free(N_Units);
  }

  free(Select);
  free(IDBsplit);

  free(ALGN_NAME);
  free(PAIR_NAME);

  Catenate(NULL,NULL,NULL,NULL);
  Numbered_Suffix(NULL,0,NULL);
  free(Prog_Name);

  exit (0);
}
